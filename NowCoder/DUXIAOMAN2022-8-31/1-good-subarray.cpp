// 好的子数组的数量
// 时间限制： 3000MS
// 内存限制： 589824KB
// 题目描述：
// 现在一个数组被定义为好的，如果该数组中的最大值是最小值的k倍。
// 现在给你一个数组，你的任务是计算有多少个子数组是好的。
// 其中，子数组定义为原数组中一段连续的数组。
// 例如：[4, 3, 2, 7]有以下几个子数组：
// [4], [4, 3], [4, 3, 2], [4, 3, 2, 7], [3], [3, 2], [3, 2, 7], [2], [2, 7], [7]
// 当k = 2时，答案为1，只有[4, 3, 2]是好数组，它的最大值是4，最小值是2，满足题意。

// 1<= n, k <= 1000

// 对于全体数据都保证数组中的数字在[1, 1e9]范围内
//        输入描述
// 第一行是一个正整数n, k，表示数组长度为n，好数组中最大值是最小值的k倍。
// 第二行是n个以空格分开的正整数。依次表示这个数组中的数字。

// 输出描述
// 一行一个非负整数，表示这个数组有几个子数组是好的。

// 样例输入
// 4 2
// 4 3 2 7
// 样例输出
// 1

// 提示
// 输入样例2
// 4 3
// 3 9 3 9

// 输出样例2
// 6

// 输入样例3
// 2 1
// 2 2

// 输出样例
// 3


// 暴力枚举子数组可通过
#include <bits/stdc++.h>

using namespace std;

int main() {
    int n = 0, k = 0;
    cin >> n >> k;
    vector<int> nums(n, 0);
    for (int i = 0; i < n; ++i) {
        int tmp = 0;
        cin >> tmp;
        nums[i] = tmp;
    }


    int res = 0;
    for (int i = 0; i < n; ++i) {

        int l = i;
        for (int j = i + 1; j < n; ++j) {
            int r = j;

            int curMin = 1001, curMax = 0;
            while (l < r) {
                curMin = min(curMin, nums[l]);
                curMax = max(curMax, nums[l]);

                if (curMax / curMin == k) {
                    res++;
                }
                l++;
            }

        }
    }

    cout << res << endl;

    return 0;
}